package problems;

import java.math.BigInteger;

import utilities.PrimeNumbersGenerator;

/**
 * @author Andre
 *
 */
public class ProjectEuler {
	
	/**
	 * @param limit
	 * @return Returns the sum of all numbers from 0 to limit dividible by three or five
	 */
	public int sumMultiplesOfThreeAndFive(int limit){
		int sum = 0;
		for (int i = 0; i < limit; i++){
			if (i%3 == 0|| i%5 == 0){
				sum +=i;
			}
		}
		return sum;
	}
	
	
	/**
	 * @param maxFibValue
	 * @return Returns sum of all even fibonacci numbers whose value does not exceed maxFibValue
	 */
	public int sumOfEvenFibNumbers(int maxFibValue) {
		int sum = 0;
		int previousFib = 0;
		int currentFib = 1;
		int newFib = 0;
		
		while (currentFib < maxFibValue){
			newFib = previousFib + currentFib;
			if (newFib % 2 == 0){
				sum += newFib;
			}
			previousFib = currentFib;
			currentFib = newFib;
		}		
		return sum;
	}
	
	
	/**
	 * @param number
	 * @return Returns the largest prime factor of the input number
	 */
	public int findLargestPrimeFactor(double number) {
		for (double i = 2; i < Math.sqrt(number); i++){			
			if (number % i == 0){
				return findLargestPrimeFactor(number/i);
			}
		}
		return (int) number;
	}
	
	
	/**
	 * @param startFactor
	 * @return Returns the largest palindrome product of two numbers whose value is from 1 to input.
	 */
	public int findLargestPalindromeProduct(int startFactor) {
		int max = 0;
		for (int i = 0; i < startFactor; i++){
			for (int j = 0; j < startFactor; j++){				
				int product = (startFactor - i) * (startFactor - j);
				if (isPalindrome(Integer.toString(product)) && product > max){
					max = product;
				}			
			}			
		}
		
		return max;
	}
	
	private boolean isPalindrome(String str){
		for (int i = 0; i < str.length()/2; i++){		
			if (str.charAt(i) != str.charAt(str.length()-1-i)){
				return false;
			}
		}		
		return true;
	}
	
	
	/**
	 * @param n
	 * @return Returns the lowest positive integer divisible by all numbers from 1 to n.
	 */
	public int leastCommonMultiple(int n) {		
		int number = 1;
		int divisor = n;
		
		for (int value : new PrimeNumbersGenerator().generatePrimesWhoseValueDoesNotExceedN(n)){
			number *= value;
		}	
		
		int productOfPrimes = number;
		
		while (divisor > 1){
			if (number % divisor == 0){
				divisor--;
			} else {
				number += productOfPrimes;
				divisor = n;
			}
		}
		
		return number;
	}
	
	
	/**
	 * @param n
	 * @return Returns the difference of the sum of the squares of the n first natural numbers, and the square of the sum of the first n natural numbers.
	 */
	public int sumSquareDifference(int n) {
		int squareOfSum = (int) Math.pow( ((n+1)*n)/2, 2);				
		int sumOfSquares = 0;
		
		for (int i = 0; i < n+1; i++) {
			sumOfSquares += i*i;
		}
		
		return squareOfSum - sumOfSquares;
	}
	
	
	/**
	 * Problem 6, find the 10001st prime
	 * @param n
	 * @return Returns the n-th prime number
	 */
	
	public int nThPrime(int n) {
		if (n == 1){
			return 2;
		}
		
		int iterator = 3;
		int number = 3;
		int numbersFound = 1;
		
		while (numbersFound < n) {
			 if (number != iterator  && number % iterator == 0 ){		// is not prime
				iterator = 3;
				number += 2;
			}
			else if (iterator == number) {		// is prime
				iterator = 3;
				numbersFound++;
				if (numbersFound == n){
					return number;
				}
				number+=2;
			} 
			else {
				iterator++;
			}
		}
		
		return 0;
	}	
	
	
	/**
	 * @param inString
	 * @return Returns the largest product of five consecutive numbers in the input-string.
	 */
	public int largestProductOfFiveConsecutiveNumbers(String inString){
		int maxFound = 0;
		
		for (int i = 0; i < inString.length() - 4; i++) {
			String subString = inString.substring(i, i+5);
			int number = 1;
			
			for (int j = 0; j < 5; j++) {
				number *= Character.getNumericValue(subString.charAt(j));
			}
			
			if (number > maxFound){
				maxFound = number;
			}
		}
		
		return maxFound;		
	}
	
	
	/**
	 * @param n
	 * @return Returns the product of a pythagorean triple whose sum is equal to the input
	 */
	public int pythagoreanTriple(int n) {
//		int a = 1;
//		int b = 2;
//		
//		for (int i = 0; i < n/2; i++) {
//			
//			for (int j = 0; j < n/2; j++) {
//				
//				int aSquared = (a+i)*(a+i);
//				int bSquared = (b+i+j)*(b+i+j);
//				int cSquared = aSquared + bSquared;
//				
//				if (isPerfectSquare(cSquared)) {		// c is integer
//					int number = (int) ((a+i)+(b+i+j)+ Math.sqrt(cSquared));
//					
//					if (number == 1000){
//						return (int) ((a+i)*(b+i+j)*Math.sqrt(cSquared));
//					}
//				}
//				
//			}
//			
//		}
//		return 0;
		
		for (int a = 0; a < n/4; a++) {
			for (int b = a+1; b < n/2; b++) {
				int c = n - a - b;
				if (c*c == a*a + b*b){
					return a*b*c;
				}
			}
		}
		return 0;
	}
	
	@SuppressWarnings("unused")
	private boolean isPerfectSquare(long n){
	  if (n < 0)
	    return false;

	  long tst = (long)(Math.sqrt(n));
	  return tst*tst == n;
	}

	
	/**
	 * @param n
	 * @return Returns the sum of the first n primes
	 */
	public long sumOfPrimes(int n) {
		PrimeNumbersGenerator primeGen = new PrimeNumbersGenerator();
		Integer[] primes = primeGen.generatePrimesWhoseValueDoesNotExceedN(n);
		long sum = 0;
		
		for (int j = 0; j < primes.length; j++) {
			sum+=primes[j];
		}
		
		return sum;
	}
	
	
	/**
	 * @param grid
	 * @return Returns the greatest product of four adjacent numbers in a grid, in the same direction.
	 */
	public int largestProductInGrid(int[][] grid) {
		int max = 0;
		
		max = searchRows(grid, max);
		
		max = searchColumns(grid, max);
		
		max = searchDiagonallyUpperLeftToBottomRight(grid, max);
		
		max = searchDiagonallyBottomLeftToUpperRight(grid, max);
		
		return max;
	}


	private int searchDiagonallyBottomLeftToUpperRight(int[][] grid, int max) {
		for (int row = grid.length-1; row > 2; row--) { 
			for (int column = 0; column < grid[row].length-3; column++) {
				int value = 1;
				for (int i = 0; i < 4; i++){
					value *= grid[row-i][column+i];	
				}
				if (value > max){
					max = value;
				}
			}			
		}
		return max;
	}

	private int searchDiagonallyUpperLeftToBottomRight(int[][] grid, int max) {
		for (int row = 0; row < grid.length-3; row++) { //then diagonay downards
			for (int column = 0; column < grid[row].length-3; column++) {
				int value = 1;
				for (int i = 0; i < 4; i++){
					value *= grid[row+i][column+i];	
				}
				if (value > max){
					max = value;
				}
			}			
		}
		return max;
	}

	private int searchColumns(int[][] grid, int max) {
		for (int row = 0; row < grid.length-3; row++) { //then down
			for (int column = 0; column < grid[row].length; column++) {
				int value = 1;
				for (int i = 0; i < 4; i++){
					value *= grid[row+i][column];	
				}
				if (value > max){
					max = value;
				}
			}	
		}
		return max;
	}

	private int searchRows(int[][] grid, int max) {
		for (int row = 0; row < grid.length; row++) { //let's start by going sideways
			for (int column = 0; column < grid[row].length-3; column++) {
				int value = 1;
				for (int i = 0; i < 4; i++){
					value *= grid[row][column+i];	
				}
				if (value > max){
					max = value;
				}
			}		
		}
		return max;
	}


	
	/**
	 * @param n
	 * @return Returns which fibonacci number is the first one of length n.
	 */
	public int firstFibonacciOfLenghtN(int n) {
		int counter = 1;
		BigInteger previousFib = new BigInteger("0");
		BigInteger currentFib = new BigInteger("1");
		BigInteger newFib;
		
		while (currentFib.toString().length() < n){
			newFib = previousFib.add(currentFib);
			previousFib = currentFib;
			currentFib = newFib;
			counter++;
		}
		
		return counter;
	}	

}
